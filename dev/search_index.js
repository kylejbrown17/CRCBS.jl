var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CRCBS","category":"page"},{"location":"#CRCBS","page":"Home","title":"CRCBS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CRCBS]","category":"page"},{"location":"#CRCBS.AStar","page":"Home","title":"CRCBS.AStar","text":"AStar\n\nA* Path Planner. Fields:\n\nlogger\nreplan : if true, planner will replan with an empty conflict table following   timeout.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.AbstractCostModel","page":"Home","title":"CRCBS.AbstractCostModel","text":"`AbstractCostModel{T}`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.AbstractLowLevelEnv","page":"Home","title":"CRCBS.AbstractLowLevelEnv","text":"`AbstractLowLevelEnv{S,A,C}`\n\nDefines a prototype environment for low level search (searching for a path\nfor a single agent).\n\n`S` is the State type, `A` is the action type, and `C` is the cost type. All\nthree must be default constructible (i.e. you can call `S()`, `A()` and `C()`\nwithout throwing errors)\n\nIn general, a concrete subtype of `AbstractLowLevelEnv` may include a graph\nwhose edges are traversed by agents.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.CBSSolver","page":"Home","title":"CRCBS.CBSSolver","text":"CBSSolver\n\nPath planner that employs Conflict-Based Search.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.CompositeCostModel","page":"Home","title":"CRCBS.CompositeCostModel","text":"`CompositeCost{T}`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.ConflictTable","page":"Home","title":"CRCBS.ConflictTable","text":"A lookup table to store all conflicts that have been detected\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.ConstraintTreeNode","page":"Home","title":"CRCBS.ConstraintTreeNode","text":"A node of a constraint tree. Each node has a set of constraints, a candidate\nsolution (set of robot paths), and a cost\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.DeadlineCost","page":"Home","title":"CRCBS.DeadlineCost","text":"`DeadlineCost`\n\n`DeadlineCost` is identical to `TravelTime`, except for the behavior of\n`add_heuristic_cost`.\n\nadd_heuristic_cost: `c = max(0.0, t + Î”t - deadline)`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.DiscreteConstraintTable","page":"Home","title":"CRCBS.DiscreteConstraintTable","text":"DiscreteStateTable\n\nStores constraints for a discrete state space\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.EnvDistanceHeuristic","page":"Home","title":"CRCBS.EnvDistanceHeuristic","text":"EnvDistanceHeuristic\n\nA convenience struct that allows for the distance matrix to be stored in env instead of the heuristic struct.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.FeatureExtractor","page":"Home","title":"CRCBS.FeatureExtractor","text":"FeatureExtractor\n\nAbstract type for features that may be reported about the solution to a PC-TAPF     or sequential task assignment problem\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.FullCostModel","page":"Home","title":"CRCBS.FullCostModel","text":"`FullCostModel{F,T,M<:AbstractCostModel{T}} <: AbstractCostModel{T}`\n\nThe `FullCostModel` defines all the behavior required for running CBS-based\nalgorithms.\n\nElements:\n- f::F must be callable, and defines how a vector of path costs (e.g., the\n    paths of a solution) should be combined into a single cost that reflects\n    the cost of the entire path group together\n- model::M<:AbstractCostModel{T} defines how the cost is computed during low\nlevel search (when individual paths are being compared against each other).\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.HardConflictTable","page":"Home","title":"CRCBS.HardConflictTable","text":"`HardConflictTable`\n\nStores a lookup table of planned paths for all agents.\nWhen agent `i` queries the table, `table.paths[i]` (the existing path plan\nfor agent `i`) must be subtracted so that the agent does not try to avoid\nconflicts with itself.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.LowLevelCostModel","page":"Home","title":"CRCBS.LowLevelCostModel","text":"`LowLevelCostModel{C}`\n\nThe low level cost model defines the objective to be optimized by the\nsolver at the low level. An optimal low level solver will return a path if a\nfeasible path exists) of minimal cost under the objective specified by the\nassociated LowLevelCostModel.\nThe parameter `C` defines the `cost_type` of the objective. The following\nfunctions must be implemented for a `LowLevelCostModel` to be used:\n* `get_initial_cost(model::LowLevelCostModel,env)` - returns\nthe initial_cost for a path\n* `get_transition_cost(model::LowLevelCostModel{C},path::Path,s::S,a::A,\n    sp::S) where {S,A,C}` - defines the cost associated with taking action\n    `a` from state `s` to arrive in state `sp` according to the objective\n    defined by `model` given that `s` is the \"tip\" of `path`.\n* `accumulate_cost(model::LowLevelCostModel{C}, current_cost::C,\n    transition_cost::C)` - defines how cost accumulates as new `PathNode`s\n    are added to a Path.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.LowLevelSolution","page":"Home","title":"CRCBS.LowLevelSolution","text":"`LowLevelSolution{S,A,T,C}`\n\nContains a list of agent paths and the associated costs.\nParams:\n- `S` is the state type\n- `A` is the action type\n- `T` is the cost type\n- `C` is the cost model type\nElements:\n- `paths::Vector{Path{S,A,T}}` is the vector of paths\n- `costs::Vector{T}` is the vector of costs, one per path\n- `cost::T` is the total cost for the entire solution\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MAPF","page":"Home","title":"CRCBS.MAPF","text":"A MAPF is a Multi Agent Path Finding problem. It consists of an environment,\n`env`, through which a group of agents may navigate, as well as a list of\nstart and goal states in that environment. Note that this is the _labeled_\ncase, where each agent has a specific assigned destination.\n\nElements:\n- env::E - the base environment\n- starts::Vector{S} - the vector of initial states\n- starts::Vector{G} - the vector of goals\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MetaAgentCBS_Solver","page":"Home","title":"CRCBS.MetaAgentCBS_Solver","text":"MetaAgentCBS_Solver\n\nPath planner that employs Meta Agent Conflict-Based Search\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MetaCost","page":"Home","title":"CRCBS.MetaCost","text":"`MetaCost`\n\n`MetaCost` maintaining separate costs for individual agents that have been\ncombined into a MetaAgent.\n- independent_costs::Vector{T} a vector of costs, 1 per agent\n- total_cost::T the total cost, which reflects the combined cost (its\n    interpretation depends on the `MetaCostModel` used to define cost-\n    upating behavior)\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MetaCostModel","page":"Home","title":"CRCBS.MetaCostModel","text":"`MetaCostModel`\n\nDefines the cost-updating behavior of `MetaCost` for MetaAgent applications.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MetaSolution","page":"Home","title":"CRCBS.MetaSolution","text":"MetaSolution{S}\n\nWrapper for a LowLevelSolution that allows for keeping track of groups.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MultiDeadlineCost","page":"Home","title":"CRCBS.MultiDeadlineCost","text":"`MultiDeadlineCost`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.MultiStagePerfectHeuristic","page":"Home","title":"CRCBS.MultiStagePerfectHeuristic","text":"`MultiStagePerfectHeuristic`\n\nStores multiple lookup tables corresponding to different stages of a Path-\nFinding search. Each stage has a different goal. The heuristic value at a\nparticular stage must reflect not just the distance to the next goal but the\nlength of the path through all remaining goals.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.NullHeuristic","page":"Home","title":"CRCBS.NullHeuristic","text":"`NullHeuristic`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.PIBTCache","page":"Home","title":"CRCBS.PIBTCache","text":"PIBTCache{S,A}\n\nContains info to be passed along through recursive calls to the PIBT algorithm for multi-agent path planning. Info to be stored:\n\ncurrent state of each agent (should be lined up at the same time step)\npriority of each agent\nthe planned action (and associated next state) for each agent\nthe search environment for each agent, which contains e.g., the agent's goal,   costmodel, heuristicmodel, etc.\na conflict table of sorts to indicate which states/actions are reserved\ncountdown flags that identify which paths are \"active\". If pibt is operating\n\non a \"ragged\" plan, where some paths have been planned further into the future than others, it needs to ensure that planning does not continue for a given path until all of the other paths have \"caught up\" to it.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.PIBTPlanner","page":"Home","title":"CRCBS.PIBTPlanner","text":"PIBTPlanner{C}\n\nPlanner based on Priority Inheritance with BackTracking. \n\nPriority Inheritance with Backtracking for Iterative Multi-agent Path Finding Okumura et al, IJCAI 2019 https://www.ijcai.org/Proceedings/2019/0076.pdf\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.PIBTReservationTable","page":"Home","title":"CRCBS.PIBTReservationTable","text":"PIBTReservationTable\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.Path","page":"Home","title":"CRCBS.Path","text":"`Path{S,A,C}`\n\nEncodes a motion plan as a sequence of `PathNode{S,A}`s\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.PathNode","page":"Home","title":"CRCBS.PathNode","text":"`PathNode{S,A}`\n\nIncludes current state `s`, action `a`, next state `sp`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.PerfectHeuristic","page":"Home","title":"CRCBS.PerfectHeuristic","text":"`PerfectHeuristic`\n\nThe Perfect Heuristic stores the exact distance between any vertex in a\ngraph to all goal vertices specified during construction. The distances are\nstored in `dists`, a dictionary which maps a goal vertex `v` to a vector of\ndistances from any other vertex in `1:nv(G)` to `v`.\n\nAn example of how to access the distance from vertex `v1` to goal `v2`:\n`get_heuristic_cost(h,v1,v2) = h.dists[v2][v1]`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.ReservationTable","page":"Home","title":"CRCBS.ReservationTable","text":"ReservationTable\n\nData structure for reserving resources over a time interval. The table stores a vector of reservations for each resource. When a new reservation is added to the table, it is inserted into the reservation vector associated to the requested resource.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.ResourceReservation","page":"Home","title":"CRCBS.ResourceReservation","text":"ResourceReservation\n\nr::ResourceReservation encodes a that resource r.resource is reserved by agent r.agent_id over time interval r.interval.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.SoftConflictTable","page":"Home","title":"CRCBS.SoftConflictTable","text":"`SoftConflictTable`\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.SoftConflictTable-2","page":"Home","title":"CRCBS.SoftConflictTable","text":"`construct_empty_lookup_table(graph,T::Int)`\n\nReturns a soft lookup table to encode possible paths for each agent through graph. The argument T defines the time horizon of the lookup table.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.SolverException","page":"Home","title":"CRCBS.SolverException","text":"SolverException\n\nCustom exception type for tracking solver timeouts, etc.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.SolverLogger","page":"Home","title":"CRCBS.SolverLogger","text":"SolverLogger\n\nA logger type for keeping track of thing like runtime, iterations, optimality gap (including upper and lower bound), etc. The following methods allow for  accessing and modifying the SolverLogger's fields, and are extended to solver types that wrap a SolverLogger:\n\niterations(logger)       iterationlimit(logger)  maxiterations(logger)   starttime(logger)       runtimelimit(logger)    deadline(logger)         JuMP.lowerbound(logger) bestcost(logger)        verbosity(logger)        verbosity(val::Int)\t\t debug(logger)            solver_status(logger)\n\nsetiterations!(solver,val) incrementiterationcount!(logger::SolverLogger) setiterationlimit!(solver,val) setmaxiterations!(solver,val) setstarttime!(solver,val) setruntimelimit!(solver,val) setdeadline!(solver,val) setlowerbound!(solver,val) setlowerbound!(logger::SolverLogger{C},val::C) where {C} setlowerbound!(logger::SolverLogger{NTuple{N,T}},val::R) where {N,T<:Real,R<:Real} setlowerbound!(logger::SolverLogger{T},val::R) where {T<:Tuple,R<:Real} setbestcost!(solver,val) setbestcost!(logger::SolverLogger,val) setbestcost!(logger::SolverLogger{NTuple{N,T}},val::R) where {N,T<:Real,R<:Real} setbestcost!(logger::SolverLogger{T},val::R) where {T<:Tuple,R<:Real} setverbosity!(solver,val) setdebug!(solver,val)\n\nThe following methods facilitate control flow based on solver status. checktime(logger) enforcetimelimit!(logger) checkiterations(logger) enforceiterationlimit!(logger)\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.SolverWrapper","page":"Home","title":"CRCBS.SolverWrapper","text":"SolverWrapper\n\nAn abstract type whose concrete instances must have a solver field.\n\n\n\n\n\n","category":"type"},{"location":"#CRCBS.a_star!-Union{Tuple{P}, Tuple{E}, Tuple{Any,E,P}, Tuple{Any,E,P,Any}} where P<:CRCBS.AbstractPath where E<:AbstractLowLevelEnv","page":"Home","title":"CRCBS.a_star!","text":"a_star!(env,start_state)\n\nA generic implementation of the [A* search algorithm](http://en.wikipedia.org/wiki/A%2A_search_algorithm)\nthat operates on an Environment and initial state.\n\nargs:\n- `env::E <: AbstractLowLevelEnv`\n- `start_state`\n\nThe following methods must be implemented:\n- is_goal(env::E,s::S)\n- check_termination_criteria(env::E,cost::C,path::Path{S,A,C},state::S)\n- get_possible_actions(env::E,s::S)\n- get_next_state(env::E,s::S,a::A,sp::S)\n- get_transition_cost(env::E,s::S,a::A)\n- violates_constraints(env::E,s::S,path::Path{S,A,C})\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.a_star_impl!-Union{Tuple{E}, Tuple{Any,E,Any,Any,Any}} where E<:AbstractLowLevelEnv","page":"Home","title":"CRCBS.a_star_impl!","text":"The internal loop of the A* algorithm.\n\n# g(n) = cost of the path from the start node to n,\n# h(n) = heuristic estimate of cost from n to goal\n# f(n) = g(n) + h(n)\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.accumulate_cost","page":"Home","title":"CRCBS.accumulate_cost","text":"accumulate_cost(model,current_cost,transition_cost)\n\nDefines the way that a transition_cost updates the current_cost of a Path.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.action_space_trait-Tuple{Any}","page":"Home","title":"CRCBS.action_space_trait","text":"action_space_trait(env)\n\nDefaults to DiscreteSpace\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.add_conflict!-Tuple{ConflictTable,Any}","page":"Home","title":"CRCBS.add_conflict!","text":"helper to insert conflicts into ConflictTable\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.add_constraint!","page":"Home","title":"CRCBS.add_constraint!","text":"Adds a CBSConstraint to a DiscreteConstraintTable \n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.add_constraint!-Union{Tuple{N}, Tuple{Any,N,CBSConstraint}} where N<:ConstraintTreeNode","page":"Home","title":"CRCBS.add_constraint!","text":"adds a `CBSConstraint` to a ConstraintTreeNode\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.add_fat_path_to_table!","page":"Home","title":"CRCBS.add_fat_path_to_table!","text":"`add_fat_path_to_table(CAT,fat_path)`\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.add_heuristic_cost","page":"Home","title":"CRCBS.add_heuristic_cost","text":"`add_heuristic_cost(cost_model,heuristic_model,cost,h_cost)`\n\nDefines the output heuristic cost that results from combining the current path cost cost with a heuristic \"cost-to-go\" h_cost. Gener\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.add_to_path!-Tuple{Path,Any,Any,Any,Any}","page":"Home","title":"CRCBS.add_to_path!","text":"add_to_path!(path,env,s,a,sp)\n\nAdds the new (s,a,sp) tuple and its cost (under env) to path.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.aggregate_costs","page":"Home","title":"CRCBS.aggregate_costs","text":"aggregate_costs(model, costs::Vector{T}) where {T}\n\nDefines how costs from multiple distinct paths are combined into a single cost for the whole solution. For example, the aggregation function for a SumOfTravelTime objective is the sum of individual cost.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.aggregate_costs_meta-Tuple{AbstractCostModel,Vararg{Any,N} where N}","page":"Home","title":"CRCBS.aggregate_costs_meta","text":"a special version of aggregate_costs for the meta_env\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.build_env","page":"Home","title":"CRCBS.build_env","text":"`build_env(mapf::AbstractMAPF, node::ConstraintTreeNode, idx::Int)`\n\nConstructs a new low-level search environment for a conflict-based search\nmapf solver\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.cbs!-Tuple{Any,Any}","page":"Home","title":"CRCBS.cbs!","text":"Conflict-Based Search\n\nSharon et al 2012\nhttps://www.aaai.org/ocs/index.php/AAAI/AAAI12/paper/viewFile/5062/5239\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.cbs_branch!-NTuple{5,Any}","page":"Home","title":"CRCBS.cbs_branch!","text":"cbs_branch!(solver,mapf,node,conflict,priority_queue)\n\nPart of CBS interface. Defaults to splitting on the conflict and adding two nodes to the priority_queue, where each of the child nodes has one of the new complementary constraints.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.cbs_bypass!-NTuple{4,Any}","page":"Home","title":"CRCBS.cbs_bypass!","text":"cbs_bypass!(solver,mapf,node,conflict,priority_queue)\n\nPart of CBS interface. Defaults to false, but can be overridden to modify the priority_queue and/or bypass the branching step of CBS\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.cbs_update_conflict_table!-NTuple{4,Any}","page":"Home","title":"CRCBS.cbs_update_conflict_table!","text":"cbs_update_conflict_table!(solver,mapf,node,constraint)\n\nAllows for flexible conflict-updating dispatch. This function is called within     within the default cbs_branch!() method.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.check_termination_criteria","page":"Home","title":"CRCBS.check_termination_criteria","text":"`check_termination_criteria(env::E <: AbstractLowLevelEnv{S,A,C}, cost,\n    path::Path{S,A,C}, s::S)`\n\nreturns true if any termination criterion is satisfied\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.combine_agents!-Tuple{Any,Any}","page":"Home","title":"CRCBS.combine_agents!","text":"`combine_agents(conflict_table, groups::Vector{Vector{Int}})`\n\nHelper for merging two (meta) agents into a meta-agent\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.compute_path_cost-NTuple{4,Any}","page":"Home","title":"CRCBS.compute_path_cost","text":"compute_path_cost(model,env,path,i)\n\nCompute the cost of a path from scratch.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.construct_config_dataframe-Tuple{Any,Any,Any}","page":"Home","title":"CRCBS.construct_config_dataframe","text":"construct_results_dataframe(loader,solver_config,config_template)\n\nCompile results at solver_config.results_path into a DataFrame based on the features stored in solver_config.feats\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.construct_empty_lookup_table-Tuple{Int64,Int64}","page":"Home","title":"CRCBS.construct_empty_lookup_table","text":"`construct_empty_lookup_table(G,T::Int)`\n\nReturns an empty lookup table.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.construct_results_dataframe-Tuple{Any,Any,Any}","page":"Home","title":"CRCBS.construct_results_dataframe","text":"construct_results_dataframe(loader,solver_config,config_template)\n\nCompile results at solver_config.results_path into a DataFrame based on the features stored in solver_config.feats\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.convert_to_vertex_lists-Union{Tuple{Path{S,A,C}}, Tuple{C}, Tuple{A}, Tuple{S}} where C where A<:AbstractGraphAction where S<:AbstractGraphState","page":"Home","title":"CRCBS.convert_to_vertex_lists","text":"Helper for displaying Paths \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.count_conflicts-Tuple{ConflictTable,Int64,Int64}","page":"Home","title":"CRCBS.count_conflicts","text":"`count_conflicts(conflict_table::ConflictTable,i::Int,j::Int)`\n\nhelper for counting the number of conflicts between agent i and agent j\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.create_reservations","page":"Home","title":"CRCBS.create_reservations","text":"create_reservation(env,s,a,sp)\n\nMust be overriden for environment env and the relevant state / action types.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.create_reservations-2","page":"Home","title":"CRCBS.create_reservations","text":"create_reservations(env::GraphEnv,s,a,sp,t=-1)\n\nGenerates three reservations as follows\n\nt0 = get_t(s)\ntF = get_t(sp)\nt_mid = (t0+tF)/2\nreservations = [\n    ResourceReservation{Int}(s_idx,get_agent_id(env),   (t0,    t_mid)),\n    ResourceReservation{Int}(a_idx,get_agent_id(env),   (t0,    tF)),\n    ResourceReservation{Int}(sp_idx,get_agent_id(env),  (t_mid, tF)),\n]\n\nIn this way, the reservations for one path node will not interfere with those for the next path node.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.default_solution-Tuple{M} where M<:AbstractMAPF","page":"Home","title":"CRCBS.default_solution","text":"`default_solution(solver, mapf::AbstractMAPF)`\n\nDefines what is returned by the solver in case of failure to find a feasible\nsolution.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.deserialize","page":"Home","title":"CRCBS.deserialize","text":"deserialize(env,idx,t=-1)\n\nDecodes an integer encoding of a state or action of type state_type(env) or action_type(env)\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.detect_action_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2,Int64}} where P2<:Path where P1<:Path","page":"Home","title":"CRCBS.detect_action_conflict","text":"Checks for an ActionConflict between two Paths at time t \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_action_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2}} where P2<:PathNode where P1<:PathNode","page":"Home","title":"CRCBS.detect_action_conflict","text":"Detect an `ActionConflict` between two path nodes. Must be overridden for\neach specific path class\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_conflicts!-Tuple{ConflictTable,PathNode,PathNode,Int64,Int64,Int64}","page":"Home","title":"CRCBS.detect_conflicts!","text":"add detected conflicts to conflict table \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_conflicts!-Union{Tuple{P2}, Tuple{P1}, Tuple{Any,P1,P2,Int64,Int64,Int64}} where P2<:PathNode where P1<:PathNode","page":"Home","title":"CRCBS.detect_conflicts!","text":"add detected conflicts to conflict table \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_conflicts!-Union{Tuple{P2}, Tuple{P1}, Tuple{Any,P1,P2,Int64,Int64}, Tuple{Any,P1,P2,Int64,Int64,Int64}} where P2<:CRCBS.AbstractPath where P1<:CRCBS.AbstractPath","page":"Home","title":"CRCBS.detect_conflicts!","text":"detect conflicts between paths\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_conflicts!-Union{Tuple{P}, Tuple{Any,Array{P,1}}, Tuple{Any,Array{P,1},Any,Vararg{Any,N} where N}} where P<:CRCBS.AbstractPath","page":"Home","title":"CRCBS.detect_conflicts!","text":"Populates a `ConflictTable` with all conflicts that occur in a given vector\nof paths. Conflict checking is performed in a pairwise fashion between\nall paths.\n\nargs:\n- conflict_table        a `ConflictTable` to store the detected conflicts\n- paths:                a list of `Path`s, one for each individual agent\n- idxs                  (optional) a list of agent ids for which to check\n                        collisions against all other agents\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_state_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2,Int64}} where P2<:CRCBS.AbstractPath where P1<:CRCBS.AbstractPath","page":"Home","title":"CRCBS.detect_state_conflict","text":"Checks for a StateConflict between two Paths at time t \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.detect_state_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2}} where P2<:PathNode where P1<:PathNode","page":"Home","title":"CRCBS.detect_state_conflict","text":"Detect a `StateConflict` between two path nodes. Must be overridden for each\nspecific path class\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.extend_path!-Union{Tuple{P}, Tuple{P,Int64}} where P<:Path","page":"Home","title":"CRCBS.extend_path!","text":"extend_path!(path,T)\n\nExtends `path` to match a given length `T` by adding `PathNode`s\ncorresponding to waiting at the final state.\n\nargs:\n- path      the path to be extended\n- the desired length of the new path\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.extend_path-Union{Tuple{P}, Tuple{P,Vararg{Any,N} where N}} where P<:Path","page":"Home","title":"CRCBS.extend_path","text":"extend_path(path,T)\n\nExtends a copy of `path` to match a given length `T` by adding `PathNode`s\ncorresponding to waiting at the final state.\n\nargs:\n- path      the path to be extended\n- the desired length of the new path\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.extract_feature","page":"Home","title":"CRCBS.extract_feature","text":"extract_feature(solution,extractor,solution,solve_time)\n\nFunction must be implemented to extract features from solutions Args:\n\nsolver (pc_tapf solver)\nextractor <: FeatureExtractor\nsolution <: SearchEnv\ntimer_results::NamedTuple{t,bytes,gctime,memallocs}\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.generate_constraints_from_conflict-Tuple{Conflict}","page":"Home","title":"CRCBS.generate_constraints_from_conflict","text":"generates a Vector of (State or Action) Constraints from a conflict\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_agent_idxs-NTuple{4,Any}","page":"Home","title":"CRCBS.get_agent_idxs","text":"get_agent_idxs(solver,node,mapf,constraint)\n\nPart of CBS interface. Defaults to return the index of a single agent affected by a constraint. Can be overridden to return the index of e.g., a \"meta-agent\" (group of agents).\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_conflict_index-Tuple{PIBTCache,Any,Any,Any,Any}","page":"Home","title":"CRCBS.get_conflict_index","text":"get_conflict_index(cache,i,s,a,sp)\n\nReturns the index of an agent that currently occupies sp, or -1 if there is no such agent.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_conflicting_paths-Tuple{T} where T<:HardConflictTable","page":"Home","title":"CRCBS.get_conflicting_paths","text":"`get_conflicting_paths`\n\noperates over a lookup table and returns a dictionary mapping path index to\nthe time index at which the conflict occurred\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_conflicts-Tuple{ConflictTable,Int64,Int64}","page":"Home","title":"CRCBS.get_conflicts","text":"helper for retrieving conflicts associated with agents i and j \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_constraints-Union{Tuple{N}, Tuple{N,Int64}} where N<:ConstraintTreeNode","page":"Home","title":"CRCBS.get_constraints","text":"retrieve constraints corresponding to this node and this path\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_cost_model-Union{Tuple{E}, Tuple{C}, Tuple{A}, Tuple{S}} where E<:AbstractLowLevelEnv{S,A,C} where C where A where S","page":"Home","title":"CRCBS.get_cost_model","text":"Override this method for when the cost model has arguments \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_fat_path-Tuple{Any,Any,Int64,Int64}","page":"Home","title":"CRCBS.get_fat_path","text":"`get_fat_path(G,D,start_vtx,goal_vtx)`\n\nreturns a fat path through `G` from `start_vtx` to `goal_vtx`. Each set\nof vertices in the fat path contains all vertices with distance d1 from\nstart_vtx and distance d2 to goal_vtx, where d1+d2 == the length of the\nshortest path(s) from `start_vtx` to `goal_vtx`\n\nG is a graph, D is the distance matrix\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_fat_path_cost-Tuple{FlatFPCost,Any}","page":"Home","title":"CRCBS.get_fat_path_cost","text":"get_fat_path_cost(model,nodes)\n\nReturns a scalar cost value depending on typeof(model) and length(nodes).\n\nget_fat_path_cost(m::FlatFPCost,nodes) = 1.0\nget_fat_path_cost(m::NormalizedFPCost,nodes) = 1.0/length(nodes)\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_heuristic_cost","page":"Home","title":"CRCBS.get_heuristic_cost","text":"`get_heuristic_cost(env::E <: AbstractLowLevelEnv{S,A,C},state::S)`\n\nget a heuristic \"cost-to-go\" from `state`\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.get_infeasible_cost-Tuple{Any}","page":"Home","title":"CRCBS.get_infeasible_cost","text":"get_infeasible_cost(model)\n\nPart of cost model interface. Defaults to zero.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_infeasible_solution-Union{Tuple{MAPF{E,S,G}}, Tuple{E}, Tuple{C}, Tuple{T}, Tuple{G}, Tuple{A}, Tuple{S}} where E<:AbstractLowLevelEnv{S,A,C} where C<:AbstractCostModel{T} where T where G where A where S","page":"Home","title":"CRCBS.get_infeasible_solution","text":"`get_infeasible_solution`\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_initial_cost-Tuple{Any}","page":"Home","title":"CRCBS.get_initial_cost","text":"get_initial_cost(model)\n\nPart of cost model interface. Defaults to zero.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_initial_solution-Union{Tuple{MAPF{E,S,G}}, Tuple{E}, Tuple{C}, Tuple{T}, Tuple{G}, Tuple{A}, Tuple{S}} where E<:AbstractLowLevelEnv{S,A,C} where C<:AbstractCostModel{T} where T where G where A where S","page":"Home","title":"CRCBS.get_initial_solution","text":"`get_initial_solution`\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_level_set_nodes","page":"Home","title":"CRCBS.get_level_set_nodes","text":"get_level_set_nodes(env,s,threshold,cost=get_initial_cost(env))\n\nReturns a vector of PathNodes, where the heuristic cost (according to env) of each node falls below threshold.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.get_next_conflict-Tuple{ConflictTable}","page":"Home","title":"CRCBS.get_next_conflict","text":"`get_next_conflict(conflict_table::ConflictTable)`\n\nReturns the next conflict (temporally) that occurs in a conflict table\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_next_state","page":"Home","title":"CRCBS.get_next_state","text":"`get_next_state(env::E <: AbstractLowLevelEnv{S,A,C}, s::S, a::A)`\n\nreturns a next state s\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.get_path_cost","page":"Home","title":"CRCBS.get_path_cost","text":"`get_path_cost(env::E <: AbstractLowLevelEnv{S,A,C},path::Path{S,A,C})`\n\nget the cost associated with a search path so far\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.get_path_node-Union{Tuple{P}, Tuple{P,Int64}} where P<:CRCBS.AbstractPath","page":"Home","title":"CRCBS.get_path_node","text":"returns the `PathNode` (s,a,s') corresponding to step `t` of `path`\n\nIf `t` is greater than the length of `path`, the `PathNode` returned\nis (s,wait(s),s) corresponding to waiting at that node of the path.\n\npath[t] is the path node that begins at t-1 and terminates at t\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.get_possible_actions","page":"Home","title":"CRCBS.get_possible_actions","text":"`get_possible_actions(env::E <: AbstractLowLevelEnv{S,A,C}, s::S)`\n\nreturn type must support iteration\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.get_transition_cost","page":"Home","title":"CRCBS.get_transition_cost","text":"`get_transition_cost(env::E <: AbstractLowLevelEnv{S,A,C},s::S,a::A,sp::S)`\n\nreturn scalar cost for transitioning from `s` to `sp` via `a`\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.handle_solver_exception-Tuple{Any,Any}","page":"Home","title":"CRCBS.handle_solver_exception","text":"handle_solver_exception\n\nTakes care of printing SolverExceptions\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.hard_reset_solver!-Tuple{SolverLogger}","page":"Home","title":"CRCBS.hard_reset_solver!","text":"hard_reset_solver!(solver)\n\nTo be called when no information (other than iteration and time limits) needs to be stored.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.has_constraint-Tuple{Any,DiscreteConstraintTable,CBSConstraint}","page":"Home","title":"CRCBS.has_constraint","text":"has_constraint(env,table,c::CBSConstraint)\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.init_dataframe","page":"Home","title":"CRCBS.init_dataframe","text":"init_dataframe(feats::Tuple)\n\nInstantiate an empty dataframe based on the names and types of feature extractors in feats.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.init_mapf_2-Tuple","page":"Home","title":"CRCBS.init_mapf_2","text":"switch places\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.init_mapf_3-Tuple","page":"Home","title":"CRCBS.init_mapf_3","text":"congested\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.init_mapf_4-Tuple","page":"Home","title":"CRCBS.init_mapf_4","text":"almost switch corners. With the fat path heuristic, the paths should be:\n- Robot 1: [1,5,9,13,14,15]\n- Robot 2: [16,12,8,4,3,2]\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.init_mapf_5-Tuple","page":"Home","title":"CRCBS.init_mapf_5","text":"PIBT demo from paper\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.initialize_child_search_node-Union{Tuple{N}, Tuple{N,Any}} where N<:ConstraintTreeNode","page":"Home","title":"CRCBS.initialize_child_search_node","text":"`initialize_child_search_node(parent_node::ConstraintTreeNode)`\n\nInitialize a new `ConstraintTreeNode` with the same `solution` and\n`constraints` as the parent node\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.initialize_root_node","page":"Home","title":"CRCBS.initialize_root_node","text":"`initialize_root_node`\n\nConstruct an empty `ConstraintTreeNode` from a `AbstractMAPF` instance\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.is_available-Tuple{ReservationTable,Any,Any,Any,Any}","page":"Home","title":"CRCBS.is_available","text":"is_available\n\nReturns false if the proposed reservation is not available to any of the agent_ids\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.is_consistent-Union{Tuple{P}, Tuple{G}, Tuple{S}, Tuple{P,S,G}} where P<:Path where G where S","page":"Home","title":"CRCBS.is_consistent","text":"is_consistent(solution,mapf)\n\nCheck if solution satisfies start and end constraints\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.is_goal","page":"Home","title":"CRCBS.is_goal","text":"`is_goal(env,s)`\n\nReturns true if state `s` satisfies the goal condition of environment `env`\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.is_valid-Tuple{C} where C<:Conflict","page":"Home","title":"CRCBS.is_valid","text":"Checks if a conflict is valid \n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.load_problem","page":"Home","title":"CRCBS.load_problem","text":"load_problem(loader,filename)\n\nGeneric function that allows a problem instance to be retrived/constructed from loader (which may cache information) and filename::String (which points to a problem file).\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.low_level_search!-Union{Tuple{N}, Tuple{M}, Tuple{Any,M,N}, Tuple{Any,M,N,Any}} where N<:ConstraintTreeNode where M<:AbstractMAPF","page":"Home","title":"CRCBS.low_level_search!","text":"`low_level_search!(\n    solver,\n    mapf::AbstractMAPF,\n    node::ConstraintTreeNode,\n    idxs=collect(1:num_agents(mapf)),\n    path_finder=a_star!)`\n\nReturns a low level solution for a MAPF with constraints. The heuristic\nfunction for cost-to-go is user-defined and environment-specific\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.num_actions","page":"Home","title":"CRCBS.num_actions","text":"num_actions(env)\n\nReturns the cardinality of the single agent state space for an environment.     If the state and action spaces are finite and discrete, a discrete     constraint table may be used for fast lookup.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.num_states","page":"Home","title":"CRCBS.num_states","text":"num_states(env)\n\nReturns the cardinality of the single agent state space for an environment.     If the state and action spaces are finite and discrete, a discrete     constraint table may be used for fast lookup.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.partially_set_path!-Union{Tuple{T}, Tuple{M}, Tuple{V}, Tuple{T,Int64,Array{Int64,1}}, Tuple{T,Int64,Array{Int64,1},Int64}} where T<:HardConflictTable{V,M} where M where V","page":"Home","title":"CRCBS.partially_set_path!","text":"`partially_set_path!`\n\nOnly replaces the cached path from start_time to length(path). Useful if you\nwant the remainder of the cached path to stay in the lookup table (i.e. for\nrepairing an existing plan).\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.pibt_priority_law-NTuple{4,Any}","page":"Home","title":"CRCBS.pibt_priority_law","text":"pibt_priority_law(solver,mapf,cache,i)\n\nReturns a value that will determine the priority of agent i relative to other agents. A lower value means higher priority.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.pibt_step!","page":"Home","title":"CRCBS.pibt_step!","text":"pibt_step!(solver,mapf,i,j=-1)\n\ni is the id of the higher priority agent, j is the index of the lower priority agent.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.populate_soft_lookup_table!","page":"Home","title":"CRCBS.populate_soft_lookup_table!","text":"`populate_soft_lookup_table!(CAT,start_times,start_vtxs,goal_vtxs)`\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.recompute_cost","page":"Home","title":"CRCBS.recompute_cost","text":"recompute_cost\n\nRecompute the cost of path (according to env), beginning from initial cost c0.\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.reconstruct_path!-NTuple{4,Any}","page":"Home","title":"CRCBS.reconstruct_path!","text":"reconstruct path by working backward from the terminal state\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.remove_constraint!","page":"Home","title":"CRCBS.remove_constraint!","text":"Removes a CBSConstraint to a DiscreteConstraintTable \n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.reserve!-Union{Tuple{R}, Tuple{Array{R,1},R}} where R<:ResourceReservation","page":"Home","title":"CRCBS.reserve!","text":"reserve!(table,reservation)\n\nAttempts to add a reservation to the table. If the reservation conflicts with an existing reservation, does nothing and returns false. If successful, returns true.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.reserved_by-Union{Tuple{R}, Tuple{Array{R,1},R}} where R<:ResourceReservation","page":"Home","title":"CRCBS.reserved_by","text":"reserved_by\n\nReturns the IDs of agents who have reserved a resource within a specific time window.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.reset_solver!-Tuple{SolverLogger}","page":"Home","title":"CRCBS.reset_solver!","text":"reset_solver!(solver)\n\nResets iteration counts and start times.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.reset_undecided!-Tuple{PIBTCache}","page":"Home","title":"CRCBS.reset_undecided!","text":"Fills `undecided` with all active agents (inactive agents have already\nselected their actions)\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.run_profiling-Tuple{Any,Any}","page":"Home","title":"CRCBS.run_profiling","text":"run_profiling(config,loader)\n\nProfile the performance of one or more solvers on a set of problems defined by files in a directory. Args:\n\nconfig: A named tuple or struct with at least the following fields:\nproblem_dir::String : path to problem files.\nsolver_configs : A vector of objects, each of which has the fields:\nsolver : a solver complying with the CRCBS interface.\nresults_path::String : path at which to store results.\nfeats : A vector of Feature objects, which defines the specific\nfeatures to be extracted and saved.\nLoader: Any kind of cache on which load_problem(loader,problem_file)   can be called.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.search_constraints-Union{Tuple{N}, Tuple{Any,DiscreteConstraintTable,N}} where N<:PathNode","page":"Home","title":"CRCBS.search_constraints","text":"search_constraints(env,table,n::PathNode)\n\nReturns all `CBSConstraint`s and `CBSConstraint`s that match `n`,\nregardless of time.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.serialize","page":"Home","title":"CRCBS.serialize","text":"serialize(env,state,t=-1)\n\nEncodes a state or action as an integer\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.set_constraint!","page":"Home","title":"CRCBS.set_constraint!","text":"Sets a `CBSConstraint` value in a DiscreteConstraintTable\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.solve!-Tuple{Any,Vararg{Any,N} where N}","page":"Home","title":"CRCBS.solve!","text":"`solve!(solver, args ...)`\n\nRun the algorithm represented by `solver` on an instance of a Multi-Agent\nPath-Finding problem.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.sorted_actions-Tuple{Any,Any}","page":"Home","title":"CRCBS.sorted_actions","text":"sorted_actions(env,s)\n\nReturn a vector of actions sorted lowest cost to highest cost.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.state_space_trait-Tuple{Any}","page":"Home","title":"CRCBS.state_space_trait","text":"state_space_trait(env)\n\nDefaults to DiscreteSpace\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.states_match","page":"Home","title":"CRCBS.states_match","text":"`state_match(s1::S,s2::S)`\n\nreturns true if s1 and s2 match (not necessarily the same as equal)\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.time_to_deadline-Tuple{Any}","page":"Home","title":"CRCBS.time_to_deadline","text":"time_to_deadline(solver)\n\ntime to deadline(solver) or runtime_limit(solver)â€“whichever is shorter.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.trim_path!-Tuple{Any,Any,Any}","page":"Home","title":"CRCBS.trim_path!","text":"trim_path!(env,path,T)\n\nModify path to terminate at time step T. If length(path) < T, the path will be extended to time step T.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.trim_solution!-Tuple{Any,Any,Any}","page":"Home","title":"CRCBS.trim_solution!","text":"trim_solution!\n\nModify solution so that all paths terminate at time step T.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.update_fat_path_conflict_table!-Union{Tuple{E}, Tuple{M}, Tuple{M,AbstractArray{T,2} where T,E,Any}} where E where M<:FatPathCostModel","page":"Home","title":"CRCBS.update_fat_path_conflict_table!","text":"update_conflict_table!(table,nodes)\n\nUpdates a conflict table with a set of nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CRCBS.violates_constraints","page":"Home","title":"CRCBS.violates_constraints","text":"`violates_constraints(env::E <: AbstractLowLevelEnv{S,A,C},\n    path::Path{S,A,C},s::S,a::A,sp::S)`\n\nreturns `true` if taking action `a` from state `s` violates any constraints\nassociated with `env`\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.wait","page":"Home","title":"CRCBS.wait","text":"`wait(s)`\n\nreturns an action that corresponds to waiting at state s\n\n\n\n\n\n","category":"function"},{"location":"#CRCBS.write_results-NTuple{5,Any}","page":"Home","title":"CRCBS.write_results","text":"write_results(loader,solver_config,prob,problem_file,results)\n\nWrite results results of profiling solver_config.solver on problem prob of name problem_name. Can be overloaded to dispatch on problem type when applicable.\n\n\n\n\n\n","category":"method"},{"location":"#GraphUtils.get_graph-Tuple{GraphEnv}","page":"Home","title":"GraphUtils.get_graph","text":"GraphUtils.get_graph(env::GraphEnv)\n\nMust be implemented for all concrete subtypes of GraphEnv\n\n\n\n\n\n","category":"method"}]
}
